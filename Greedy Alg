Problem Statement:



Ram is planning activities for a person during the day. He has a list of activities, and each activity has a start time and an end time. The person can only do one activity at a time, and they need to maximize the number of activities they can participate in. His goal is to select the maximum number of non-overlapping activities. Help Ram to complete the task.

Input format :
The first line of input is an integer n, representing the number of activities.

The second line of input consists of n space-separated integers representing the start times of the activities.

The third line of input consists of n space-separated integers representing the finish times of the activities.

Output format :
The output displays the indices of the selected activities separated by a space, representing the maximum number of activities that can be performed.



Refer to the sample output for the formatting specifications.

Code constraints :
1 ≤ Start time, Finish time ≤ 100

Start time < Finish time

Sample test cases :
Input 1 :
6
1 3 0 5 8 5
2 4 6 7 9 9
Output 1 :
0 1 3 4 
code:
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> start(n), finish(n);
    for (int i = 0; i < n; i++) cin >> start[i];
    for (int i = 0; i < n; i++) cin >> finish[i];

    vector<pair<int,int>> order;
    for (int i = 0; i < n; i++) {
        order.push_back({finish[i], i});
    }

    sort(order.begin(), order.end());

    vector<int> result;
    int lastFinish = -1;

    for (auto p : order) {
        int idx = p.second; 
        if (start[idx] >= lastFinish) {
            result.push_back(idx);
            lastFinish = finish[idx];
        }
    }

    for (int i = 0; i < result.size(); i++) {
        cout << result[i] << (i == result.size()-1 ? "" : " ");
    }

    return 0;
}
You have recently been appointed as the program manager for a cricket stadium. Since it's a weekend, the stadium will be hosting multiple cricket matches throughout the day. Your goal is to organize and schedule as many matches as possible within the available time, keeping in mind that only one match can be played at a time on the ground.



Constraints:

Each match has a start time and an end time.

Once a match finishes, the ground becomes available immediately for the next match.

The maximum number of matches that need to be scheduled does not exceed 20.

You need to maximize the number of matches scheduled on the ground.

The matches should be scheduled in the order in which they are played.

The start and end times of each match are provided, and your task is to find the schedule that allows the maximum number of matches.



You are given a list of matches with their start and end times. Write a program that schedules the maximum number of non-overlapping cricket matches. The program should output the schedule of matches in the order in which they are played.

Example

Input

6

match1

1

2

match5

3

4

match4

0

6

match3

5

7

match6

8

9

match2

5

9

Output

Selected matches are:

match1 match5 match3 match6

Explanation

The shortest song is placed in the 0th index, followed by the second shortest song in the 1st index, and so on. Then the mean retrieval time is calculated.

Input format :
The first line contains an integer n – the number of matches.

The next n lines contain the following information for each match:

A string name (up to 50 characters), representing the match name.
An integer stime represents the start time of the match.
An integer ftime represents the finish time of the match.
Output format :
The output prints the statement "Selected Activities are:".

Then, print the names of the selected matches in the order in which they are played, separated by spaces.



Refer to the sample Input and output for the formatting specifications

Sample test cases :
Input 1 :
 6
match1
1
2
match5
3
4
match4
0
6
match3
5
7
match6
8
9
match2
5
9
Output 1 :
Selected Activities are:
match1 match5 match3 match6 
Input 2 :
5
ride-1
3
5
ride-2
6
8
ride-3
1
4
ride-4
4
7
ride-5
7
10
Output 2 :
Selected Activities are:
ride-3 ride-4 ride-5 
code:
// You are using GCC
#include<bits/stdc++.h>
using namespace std;
struct m{
    string name;
    int st,finish;
};
bool cmp(m a,m b){
    return a.finish<b.finish;
}
int main(){
    int n;
    cin>>n;
    vector<m> match(n);
    for(int i=0;i<n;i++){
        cin>>match[i].name;
        cin>>match[i].st;
        cin>>match[i].finish;
        
    }
    sort(match.begin(),match.end(),cmp);
    vector< string> r;
    int last=-1;
    for(int i=0;i<n;i++){
        if(match[i].st>=last){
            r.push_back(match[i].name);
            last=match[i].finish;
        }
    }
    cout<<"selected Activities are:"<<endl;
    for(auto &m : r)cout<<m<<" ";
    cout<<endl;
}


Problem Statement



You are given a knapsack with a maximum weight capacity of W and n objects. Each object i has a weight c[i] and a value v[i]. Your task is to fill the knapsack with objects in such a way that the total value of the objects in the knapsack is maximized without exceeding the weight capacity.



Implement a program to solve this problem using a simple greedy algorithm known as the Fractional Knapsack Problem.

Input format :
The first line of input consists of an integer n, representing the number of objects.

The second line of input consists of n integers, separated by a space, representing the weight of the object.

The third line of input consists of n integers, separated by a space, representing the value of the object.

The fourth line of input consists of an integer W, representing the maximum weight capacity of the knapsack.

Output format :
The output displays the following format:



For each step, it should print either:



"Added object X (Rs. Y, ZKg) completely in the bag. Space left: W." if the entire object X is added to the knapsack, where X is the object number, Rs. Y is the value of the object, ZKg is the weight of the object, and W is the remaining capacity of the knapsack as the integers.



"Added P% (Rs. Y, ZKg) of object X in the bag." if only a fraction of object X is added to the knapsack, where P% is the percentage of the object added, Rs. Y is the value of the object, ZKg is the weight of the object, and X is the object number as the integers.



Finally, it should print "Filled the bag with objects worth Rs. V." where Rs. V is the total value of the objects in the knapsack as the float-point numbers.



Refer to the sample output for the formatting specifications.

Code constraints :
1 ≤ n ≤ 10

1 ≤ c[i], v[i] ≤ 150

1 ≤ W ≤ 100

Sample test cases :
Input 1 :
3
10 20 30
60 100 120
50
Output 1 :
Added object 1 (Rs. 60, 10Kg) completely in the bag. Space left: 40.
Added object 2 (Rs. 100, 20Kg) completely in the bag. Space left: 20.
Added 66% (Rs.120, 30Kg) of object 3 in the bag.
Filled the bag with object
code:
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
using namespace std;

struct Item {
    int index;
    int value;
    int weight;
    double ratio;
};

bool cmp(const Item &a, const Item &b) {
    return a.ratio > b.ratio;
}

int main() {
    int n;
    cin >> n;

    vector<int> weights(n), values(n);
    for (int i = 0; i < n; i++) cin >> weights[i];
    for (int i = 0; i < n; i++) cin >> values[i];

    int W;
    cin >> W;

    vector<Item> items;
    for (int i = 0; i < n; i++) {
        items.push_back({i + 1, values[i], weights[i], (double)values[i] / weights[i]});
    }

    sort(items.begin(), items.end(), cmp);

    double totalValue = 0.0;
    int remainingCapacity = W;

    for (auto item : items) {
        if (remainingCapacity >= item.weight) {
            remainingCapacity -= item.weight;
            totalValue += item.value;
            cout << "Added object " << item.index << " (Rs. " << item.value << ", " 
                 << item.weight << "Kg) completely in the bag. Space left: " 
                 << remainingCapacity << "." << endl;
        } else if (remainingCapacity > 0) {
            double fraction = (double)remainingCapacity / item.weight;
            int percentage = fraction * 100;
            double addedValue = item.value * fraction;  // Only fraction value
            cout << "Added " << percentage << "% (Rs." << item.value << ", " 
                 << item.weight << "Kg) of object " << item.index << " in the bag." 
                 << endl;
            totalValue += addedValue;
            remainingCapacity = 0;
            break;
        }
    }

    cout << fixed << setprecision(2);
    cout << "Filled the bag with objects worth Rs. " << totalValue << "." << endl;

    return 0;
}


