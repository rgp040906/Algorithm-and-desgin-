Problem Statement



You are given a set of items, each with a specific weight and value. Your task is to determine the maximum value that can be obtained by selecting a combination of these items, considering a knapsack with a limited capacity. You are allowed to take fractions of items into the knapsack.



Write a program to implement the fractional knapsack problem.

Input format :
The input consists of several lines, each representing an item.

Each item is represented by two integers separated by a space: the weight of the item followed by its value.

The input terminates with a line containing a single integer -1.

After the items, there is an integer representing the maximum weight capacity.

Output format :
The output prints "The maximum value of the current list is: ", followed by a double value, representing the maximum value that can be obtained by selecting fractions of items to fit into the knapsack, rounded off to two decimal points.



Refer to the sample outputs for the exact format.

Code constraints :
The given test cases fall under the following specifications:

1 ≤ weight and values ≤ 1000

1 ≤ capacity ≤ 100

Sample test cases :
Input 1 :
10 60 
20 100
30 120
-1
50
Output 1 :
The maximum value of the current list is:
240.00
Input 2 :
10 100 
40 280
20 120 
24 120 
-1
60
Output 2 :
The maximum value of the current list is:
440.00

#include <bits/stdc++.h>
using namespace std;

struct Item {
    double weight, value;
};

int main() {
    vector<Item> items;
    double w, v;

    // Read items until -1 is encountered
    while (cin >> w) {
        if (w == -1) break;
        cin >> v;
        items.push_back({w, v});
    }

    double capacity;
    cin >> capacity;

    // Sort items by value-to-weight ratio (descending order)
    sort(items.begin(), items.end(), [](Item a, Item b) {
        return (a.value / a.weight) > (b.value / b.weight);
    });

    double totalValue = 0.0;

    for (auto &item : items) {
        if (capacity == 0)
            break;

        if (item.weight <= capacity) {
            // Take the whole item
            totalValue += item.value;
            capacity -= item.weight;
        } else {
            // Take fraction of the item
            totalValue += item.value * (capacity / item.weight);
            capacity = 0;
        }
    }

    cout << "The maximum value of the current list is:" << endl;
    cout << fixed << setprecision(2) << totalValue << endl;

    return 0;
}





Problem Statement



Jenny is currently fascinated by graph coloring algorithms and wants to understand the practical implementation of graph coloring. Develop a program that takes an undirected graph as input and assigns colors to its vertices in such a way that no two adjacent vertices have the same color. 



The graph is represented as an adjacency matrix. Helps Jenny in achieving this.

Input format :
The first line consists of an integer V, representing the number of vertices in the graph.

The next V lines consist of a pair of space-separated integers, each representing an edge between two connected vertices.

The input ends with -1, indicating the end of the input.

Output format :
For each vertex, the output prints a line indicating its assigned color in the format: "Vertex X - Color Y" where X represents the vertex number, and Y represents the color assigned to that vertex.



Refer to the sample output for the formatting specifications.

Code constraints :
1 ≤ V ≤ 50

Sample test cases :
Input 1 :
5
0 1
0 2
1 2
1 4
2 4
4 3
-1
Output 1 :
Vertex 0 - Color 0
Vertex 1 - Color 1
Vertex 2 - Color 2
Vertex 3 - Color 0
Vertex 4 - Color 3
Input 2 :
5
0 1
0 2
1 2
1 3
2 3
3 4
-1
Output 2 :
Vertex 0 - Color 0
Vertex 1 - Color 1
Vertex 2 - Color 2
Vertex 3 - Color 0
Vertex 4 - Color 1

#include <bits/stdc++.h>
using namespace std;

int main() {
    int V;
    cin >> V;

    vector<vector<int>> adj(V);
    int u, v;

    while (cin >> u) {
        if (u == -1) break;
        cin >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    vector<int> color(V, -1); 
    color[0] = 0;

    vector<bool> available(V, false);

    for (int i = 1; i < V; i++) {
        
        for (int neighbor : adj[i])
            if (color[neighbor] != -1)
                available[color[neighbor]] = true;

        int cr;
        for (cr = 0; cr < V; cr++)
            if (!available[cr])
                break;

        color[i] = cr; 


        fill(available.begin(), available.end(), false);
    }

    for (int i = 0; i < V; i++)
        cout << "Vertex " << i << " - Color " << color[i] << endl;

    return 0;
}

Problem Statement:



Rahul is a highly productive individual who wants to maximize the number of non-overlapping activities he can complete in a day. Each activity has a start time and a finish time. Rahul can only work on one activity at a time, and he cannot start a new activity until the previous one has finished.



Given a list of activities with their start and finish times, help Rahul select the maximum number of non-overlapping activities that he can perform.

Input format :
The first line contains a single integer N representing the number of activities.

The next N lines each contain two space-separated integers: start and finish

start representing the starting time of an activity.

finish represents the finishing time of an activity.

Output format :
The output prints the selected activities in the format:

(start1, finish1), (start2, finish2), ...

The activities should be printed in the order they are selected.



Refer to the sample output for the formatting specifications.

Code constraints :
1 ≤ start, finish ≤ 100

start < finish

Sample test cases :
Input 1 :
3
1 2 
3 4
6 7
Output 1 :
(1, 2), (3, 4), (6, 7)
Input 2 :
4
5 9
1 3
3 6
2 5
Output 2 :
(1, 3), (3, 6)


// You are using GCC
#include <iostream>
using namespace std;

struct Activity {
    int start, finish;
};


void sortByFinishTime(Activity a[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (a[j].finish > a[j + 1].finish) {
                Activity temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}

int main() {
    int n;
    cin >> n;

    Activity a[100];

    for (int i = 0; i < n; i++) {
        cin >> a[i].start >> a[i].finish;
    }


    sortByFinishTime(a, n);


    int lastFinish = a[0].finish;
    cout << "(" << a[0].start << ", " << a[0].finish << ")";


    for (int i = 1; i < n; i++) {
        if (a[i].start >= lastFinish) {
            cout << ", (" << a[i].start << ", " << a[i].finish << ")";
            lastFinish = a[i].finish;
        }
    }

    return 0;
}


to check the palidrome or not
#include <bits/stdc++.h>
using namespace std;

string longestPalindrome(string s) {
    string res = "";
    for (int i = 0; i < s.size(); i++)
        for (int j = i; j < s.size(); j++) {
            string t = s.substr(i, j - i + 1);
            string r = t;
            reverse(r.begin(), r.end());
            if (t == r && t.size() > res.size())
                res = t;
        }
    return res;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        cout << longestPalindrome(s) << endl;
    }
}


#include <bits/stdc++.h>
using namespace std;
int main() {
    string s; cin >> s;
    int n = s.size(), len = 0;
    for (int i = 1; i < n; i++)
        if (s.substr(0, i) == s.substr(n - i)) len = i;
    cout << len;
}


#include <bits/stdc++.h>
using namespace std;

int main() {
    string s1, s2;
    cin >> s1 >> s2;
    int n = s1.size(), m = s2.size(), maxlen = 0, end = 0;
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] > maxlen) {
                    maxlen = dp[i][j];
                    end = i;
                }
            }
        }
    }
    if (maxlen == 0) cout << "There is no common substring";
    else cout << s1.substr(end - maxlen, maxlen);
}

lps
// You are using GCC
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<int> arr(N);
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }

    vector<int> dp(N, 1); // each element alone is LIS of length 1

    for (int i = 1; i < N; i++) {
        for (int j = 0; j < i; j++) {
            if (arr[i] > arr[j]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }

    int lisLength = *max_element(dp.begin(), dp.end());
    cout << "Length of the longest increasing subsequence: " << lisLength << endl;

    return 0;
}

aaabbaaa

#include <bits/stdc++.h>
using namespace std;

string shortestPalindrome(string s) {
    string rev = s;
    reverse(rev.begin(), rev.end());
    string temp = s + "#" + rev;
    vector<int> lps(temp.size(), 0);

    for (int i = 1; i < temp.size(); i++) {
        int len = lps[i - 1];
        while (len > 0 && temp[i] != temp[len])
            len = lps[len - 1];
        if (temp[i] == temp[len]) len++;
        lps[i] = len;
    }

    return rev.substr(0, s.size() - lps.back()) + s;
}

int main() {
    string s;
    cin >> s;
    cout << shortestPalindrome(s);
}



lcs
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s;
    cin >> s;
    string r = s;
    reverse(r.begin(), r.end());
    int n = s.size();
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            dp[i][j] = (s[i - 1] == r[j - 1])
                        ? 1 + dp[i - 1][j - 1]
                        : max(dp[i - 1][j], dp[i][j - 1]);

    cout << dp[n][n];
}

lcs
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s1, s2;
    getline(cin, s1);
    getline(cin, s2);

    int n = s1.size(), m = s2.size();
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            dp[i][j] = (s1[i - 1] == s2[j - 1]) ? dp[i - 1][j - 1] + 1 
                                                : max(dp[i - 1][j], dp[i][j - 1]);

    cout << "Length of LCS: " << dp[n][m];
}



#include <bits/stdc++.h>
using namespace std;

void backtrack(string &s1, string &s2, vector<vector<int>> &dp, int i, int j, string path, set<string> &result) {
    if (i == 0 || j == 0) {
        reverse(path.begin(), path.end());
        result.insert(path);
        return;
    }

    if (s1[i - 1] == s2[j - 1]) {
        backtrack(s1, s2, dp, i - 1, j - 1, path + s1[i - 1], result);
    } else {
        if (dp[i - 1][j] >= dp[i][j - 1])
            backtrack(s1, s2, dp, i - 1, j, path, result);
        if (dp[i][j - 1] >= dp[i - 1][j])
            backtrack(s1, s2, dp, i, j - 1, path, result);
    }
}

int main() {
    string s1, s2;
    getline(cin, s1);
    getline(cin, s2);

    int n = s1.size(), m = s2.size();
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    // Build LCS DP table
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            dp[i][j] = (s1[i - 1] == s2[j - 1]) 
                        ? dp[i - 1][j - 1] + 1 
                        : max(dp[i - 1][j], dp[i][j - 1]);

    set<string> result;
    backtrack(s1, s2, dp, n, m, "", result);

    // Print all unique LCS combinations
    for (auto &r : result)
        if (!r.empty())
            cout << r << "\n";

    cout << "The length of the Longest Common Subsequence is: " << dp[n][m] << endl;
    return 0;
}

This is test


cat rat 
#include <bits/stdc++.h>
using namespace std;

int minEditCost(string s1, string s2) {
    int n = s1.size(), m = s2.size();
    int cost = 5; // Cost for insert, delete, replace

    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            if (i == 0)
                dp[i][j] = j * cost; // Insert all characters
            else if (j == 0)
                dp[i][j] = i * cost; // Delete all characters
            else if (s1[i - 1] == s2[j - 1])
                dp[i][j] = dp[i - 1][j - 1]; // Characters match
            else



                dp[i][j] = min({dp[i - 1][j] + cost,     // Delete
                                dp[i][j - 1] + cost,     // Insert
                                dp[i - 1][j - 1] + cost} // Replace
                               );
        }
    }
    return dp[n][m];
}

int main() {
    string doc1, doc2;
    cin >> doc1 >> doc2;

    cout << minEditCost(doc1, doc2);
    return 0;
}

#include <bits/stdc++.h>
using namespace std;

int main() {
    string m1, m2;
    cin >> m1 >> m2;
    int ins, del, sub;
    cin >> ins >> del >> sub;

    int n = m1.size(), m = m2.size();
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            if (i == 0)
                dp[i][j] = j * ins;  // Insert all
            else if (j == 0)
                dp[i][j] = i * del;  // Delete all
            else if (m1[i - 1] == m2[j - 1])
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = min({dp[i][j - 1] + ins,   // Insert
                                dp[i - 1][j] + del,   // Delete
                                dp[i - 1][j - 1] + sub}); // Substitute
        }
    }

    cout << dp[n][m];
    return 0;
}


// You are using GCC
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> coins(n);
    for(int i = 0; i < n; i++) {
        cin >> coins[i];
    }
    int s;
    cin >> s;
    
    vector<long long> dp(s + 1, 0);
    dp[0] = 1;
    
    for(int coin : coins) {
        for(int j = coin; j <= s; j++) {
            dp[j] += dp[j - coin];
        }
    }
    
    cout << dp[s] << endl;
    return 0;




[11/6/2025 5:52 AM] ʀ ɢ ᴘʀᴀꜱᴀɴɴᴀ: #include <bits/stdc++.h>
using namespace std;

int main() {
    string s;
    cin >> s;
    int n = s.size();
    string rev = s;
    reverse(rev.begin(), rev.end());

    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (s[i - 1] == rev[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }

    cout << dp[n][n];
    return 0;
}
[11/6/2025 5:52 AM] ʀ ɢ ᴘʀᴀꜱᴀɴɴᴀ: lps
[11/6/2025 5:52 AM] ʀ ɢ ᴘʀᴀꜱᴀɴɴᴀ: #include <bits/stdc++.h>
using namespace std;

int main() {
    string s1, s2;
    getline(cin, s1);
    getline(cin, s2);

    int n = s1.size(), m = s2.size();
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            dp[i][j] = (s1[i - 1] == s2[j - 1]) ? dp[i - 1][j - 1] + 1 
                                                : max(dp[i - 1][j], dp[i][j - 1]);

    cout << "Length of LCS: " << dp[n][m];
}
[11/6/2025 5:52 AM] ʀ ɢ ᴘʀᴀꜱᴀɴɴᴀ: lcs
[11/6/2025 5:52 AM] ʀ ɢ ᴘʀᴀꜱᴀɴɴᴀ: // You are using GCC
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<int> arr(N);
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }

    vector<int> dp(N, 1); // each element alone is LIS of length 1

    for (int i = 1; i < N; i++) {
        for (int j = 0; j < i; j++) {
            if (arr[i] > arr[j]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }

    int lisLength = *max_element(dp.begin(), dp.end());
    cout << "Length of the longest increasing subsequence: " << lisLength << endl;

    return 0;
}
[11/6/2025 5:52 AM] ʀ ɢ ᴘʀᴀꜱᴀɴɴᴀ: lis






